//// about spaces

// we have these spaces:
// - scala
//   - scala.main
//     - scala.main.jawn_0_10
//     - scala.main.jawn_0_11
// the jawn split is because sbt 1 uses jawn 0.10.x (via its dependency
// on sjson-new) and the sbt team doesn't want to break  binary compatibility
// of sbt plugins. nearly everything else is on jawn 0.11, and the two versions
// are source-incompatible.

//// from environment

vars: {
  scala-version: ""
  scala-version: ${?version}
  scalac-opts: ""
  scalac-opts: ${?scalac_opts}
  node: "node" // node-js
  node: ${?NODE}
}

//// vars.base

// Each project is prefixed by ${vars.base} { ...
// so that common options or settings can be set by the
// configuration that includes this common file.
// Note however that += won't work inside vars.base.
// It's https://github.com/lightbend/config/issues/160.
// That's why if you override extra.commands you must
// explicitly include default-commands.

vars: {
  base: {}
}

include file(".dbuild/project-refs.conf")
include file(".dbuild/resolvers.conf")

//// shared settings

vars {
  default-commands: []
  sbt-0-13-version: "0.13.18"
  sbt-version: "1.2.8"
}

//// compiler options manipulation

// appendScalacOptions, removeScalacOptions, removeDependency
// let us work around https://github.com/lightbend/dbuild/issues/144
vars.default-commands += """
set commands ++= {
  // TODO: maybe Eugene & Dale could help eliminate the copy-and-paste
  // between alterSetting and alterTask...?
  def alterSetting[T](s: State, setting: SettingKey[T])(fn: T => T): State = {
    val extracted = Project extract s
    import extracted._
    val r = Project.relation(extracted.structure, true)
    val allDefs = r._1s.toSeq
    val scopes = allDefs.filter(_.key == setting.key).map(_.scope).distinct
    val redefined = scopes.map(scope => setting in scope ~= fn)
    val session = extracted.session.appendRaw(redefined)
    BuiltinCommands.reapply(session, structure, s)
  }
  def alterTask[T](s: State, task: TaskKey[T])(fn: T => T): State = {
    val extracted = Project extract s
    import extracted._
    val r = Project.relation(extracted.structure, true)
    val allDefs = r._1s.toSeq
    val scopes = allDefs.filter(_.key == task.key).map(_.scope).distinct
    val redefined = scopes.map(scope => task in scope ~= fn)
    val session = extracted.session.appendRaw(redefined)
    BuiltinCommands.reapply(session, structure, s)
  }
  def appendScalacOptions(s: State, args: Seq[String]): State = {
    def appendDistinct[A](x: Seq[A], y: Seq[A]) =
      x.filterNot(y.contains) ++ y
    alterTask(s, scalacOptions)(appendDistinct(_, args))
  }
  def removeScalacOptions(s: State, args: Seq[String]): State =
    alterTask(s, scalacOptions)(_.filterNot(args.contains))
  def removeDependency(s: State, args: Seq[String]): State = {
    require(args.size == 2)
    alterSetting(s, libraryDependencies)(
      _.filterNot(mod => mod.organization == args(0) && mod.name == args(1)))
  }
  Seq(
    Command.args("appendScalacOptions", "<option>")(appendScalacOptions),
    Command.args("removeScalacOptions", "<option>")(removeScalacOptions),
    Command.args("removeDependency", "<org> <artifact>")(removeDependency))
}
"""
vars.default-commands += "appendScalacOptions "${vars.scalac-opts}
vars.default-commands += "removeScalacOptions -Xfatal-warnings"
vars.base.extra.commands = ${vars.default-commands}

//// count lines of code

vars.base.extra.settings = ["""libraryDependencies in ThisBuild += compilerPlugin("com.lightbend" %% "cloc-plugin" % "0")"""]
vars.base.deps.inject: ["com.lightbend#cloc-plugin"]

//// cache

// new behemoths have much more disk space, so let's try keeping stuff
// substantially longer (2 weeks instead of 4-5 days) and see what
// the effect on disk space usage is, starting March 17 2018
options.cleanup: {
  extraction: {
    success: 336
    failure: 336
  }
  build: {
    success: 336
    failure: 336
  }
}

//// Scala itself

build += {
  sbt-version: ${vars.sbt-version}
  extraction-version: ${vars.scala-version}

  space: scala

  projects: [
  {
    name: "cloc-plugin"
    uri:  "https://github.com/SethTisue/cloc-plugin.git"
  }
  {
    name:  "scala"
    system: assemble
    cross-version: binary
    extra.parts.projects: [
      {
        set-version: ${vars.scala-version}
        name:   scala-library
        system: aether
        uri:   "aether:org.scala-lang#scala-library;"${vars.scala-version}
        extra.sources: true  // Scala.js wants this
      }
      {
        set-version: ${vars.scala-version}
        name:   scala-reflect
        system: aether
        uri:   "aether:org.scala-lang#scala-reflect;"${vars.scala-version}
      }
      {
        set-version: ${vars.scala-version}
        name:   scala-compiler
        system: aether
        uri:   "aether:org.scala-lang#scala-compiler;"${vars.scala-version}
      }
      {
        name: "scala-xml"
        // master has moved to a new 2.x series, but the Scala 2.12 compiler
        // is going to continue depending on 1.x, in fact Scala 2.12 will
        // probably stay frozen at 1.0.6 forever. but the v1.0.6 tag won't
        // build on JDK 11, so let's use the 1.x branch
        uri: "https://github.com/scala/scala-xml.git#1.x"
        // this gives us "scala-xml_2.11" which is what we want, sbt 1 will get
        // upset if there are two different kinds of scala-xml dependencies
        // floating around (https://github.com/scala/community-builds/issues/679)
        cross-version: standard
        // override sbt version here since otherwise we get
        // whatever random sbt version the module has
        extra.sbt-version: ${vars.sbt-0-13-version}
        extra.commands: ${vars.default-commands} [
          // override scalaVersion here since otherwise we get
          // whatever random Scala version the module has
          "set every scalaVersion := \""${vars.scala-version}"\""
          // work around https://github.com/scala/community-builds/issues/575
          // (in a community build context, we don't need MiMa to run)
          "set every ScalaModulePlugin.mimaPreviousVersion := None"
        ]
        extra.projects: ["xml"]
      }
      {
        name: "scala-parser-combinators"
        uri:  ${vars.uris.scala-parser-combinators-uri}
        cross-version: standard
        extra.sbt-version: ${vars.sbt-0-13-version}
        extra.projects: ["scala-parser-combinatorsJVM"]
        extra.commands: ${vars.base.extra.commands} [
          // override scalaVersion here since otherwise we get
          // whatever random Scala version the module has
          "set every scalaVersion := \""${vars.scala-version}"\""
          // work around https://github.com/scala/community-builds/issues/575
          // (in a community build context, we don't need MiMa to run)
          "set every ScalaModulePlugin.mimaPreviousVersion := None"
        ]
      }
    ]
  }

]}

//// space: scala.main

build += {

  space: scala.main

  check-missing: [ true, false ]
  cross-version: [ disabled, standard ]
  extraction-version: ${vars.scala-version}
  sbt-version: ${vars.sbt-version}

  projects: [

  // frozen (February 2019) at a December 2018 commit
  // because of a downstream circe failure, reported here:
  // https://github.com/circe/circe/issues/1084
  ${vars.base} {
    name: "scalacheck"
    uri:  ${vars.uris.scalacheck-uri}
    extra.projects: ["jvm"]  // no Scala.js please
  }

  // see also scalatest-tests
  // forked for: build tweak, JDK 11 friendliness, comment out a test
  // fork refreshed (from 3.0.x branch) January 2019
  ${vars.base} {
    name: "scalatest"
    uri:  ${vars.uris.scalatest-uri}
    extra.sbt-version: ${vars.sbt-0-13-version}
    extra.projects: ["scalatest", "scalactic"]
  }

  ${vars.base} {
    name: "scala-js-stubs"
    uri:  ${vars.uris.scala-js-stubs-uri}
  }

  ${vars.base} {
    name: "macro-paradise"
    uri:  ${vars.uris.macro-paradise-uri}
    extra.sbt-version: ${vars.sbt-0-13-version}
  }

  ${vars.base} {
    name: "shapeless"
    uri:  ${vars.uris.shapeless-uri}
    extra.projects: ["coreJVM"]
  }

  ${vars.base} {
    name: "kind-projector"
    uri:  ${vars.uris.kind-projector-uri}
  }

  ${vars.base} {
    name: "specs2"
    uri:  ${vars.uris.specs2-uri}
    // I don't see a project that aggregates JVM-only stuff, so...
    extra.projects: [
      "analysisJVM", "commonJVM", "coreJVM", "fpJVM"
      "matcherExtraJVM", "matcherJVM", "mockJVM", "junitJVM"
      "scalacheckJVM"
    ]
    // makes "configuration not public" errors downstream go away
    extra.commands: ${vars.default-commands} [
      "set every publishMavenStyle := false"
    ]
  }

  ${vars.base} {
    name: "scala-collection-compat"
    uri:  ${vars.uris.scala-collection-compat-uri}
    extra.projects: ["compat212"]  // no Scala.js or Scalafix rules plz
  }

  // dependency of cats
  // temporarily forked (April 2019) pending merge of https://github.com/milessabin/export-hook/pull/34
  ${vars.base} {
    name: "export-hook"
    uri:  ${vars.uris.export-hook-uri}
    extra.sbt-version: ${vars.sbt-0-13-version}
    extra.projects: ["coreJVM"]  // no Scala.js plz
  }

  ${vars.base} {
    name: "scala-java-time"
    uri:  ${vars.uris.scala-java-time-uri}
    extra.projects: ["scalajavatimeJVM", "scalajavatimeTZDBJVM", "scalajavatimeTestsJVM"]  // no Scala.js plz
  }

  ${vars.base} {
    name: "simulacrum"
    uri:  ${vars.uris.simulacrum-uri}
    extra.projects: ["coreJVM", "examplesJVM"] // no Scala.js please
    extra.commands: ${vars.base.extra.commands} [
      // otherwise sbt-gpg errors on `publish`
      "set every gpgWarnOnFailure := true"
      // we have wartremover, but it's better to avoid the dependency if we can, to help
      // the dependency structure flatter overall
      "removeDependency org.wartremover wartremover"
      "removeScalacOptions -P:wartremover:traverser:org.wartremover.warts.ExplicitImplicitTypes -P:wartremover:traverser:org.wartremover.warts.ImplicitConversion"
    ]
    deps.ignore: ["org.wartremover#wartremover"]
  }

  // frozen (April 2019) at April 2019 commit before source-incompatible upgrade
  // to ScalaTest 3.1
  ${vars.base} {
    name: "discipline"
    uri:  ${vars.uris.discipline-uri}
    extra.projects: ["disciplineJVM"]  // no Scala.js please
  }

  // frozen (March 2018) at a March 2018 commit before an sbt-catalysts version
  // bump -- the new version wouldn't resolve, not sure why
  ${vars.base} {
    name: "catalysts"
    uri:  ${vars.uris.catalysts-uri}
    // other projects aren't pertinent or errored out (not investigated)
    extra.projects: ["specbaseJVM", "lawkitJVM", "scalatestJVM", "macrosJVM", "platformJVM", "testkitJVM"]
  }

  ${vars.base} {
    name: "machinist"
    uri:  ${vars.uris.machinist-uri}
    extra.projects: ["machinistJVM"]  // no Scala.js please
  }

  ${vars.base} {
    name: "macro-compat"
    uri:  ${vars.uris.macro-compat-uri}
    extra.sbt-version: ${vars.sbt-0-13-version}
    // no Scala.js plz
    extra.projects: ["testJVM"]
  }

  ${vars.base} {
    name: "wartremover"
    uri:  ${vars.uris.wartremover-uri}
    extra.exclude: ["sbt-plugin"]
    deps.ignore: ["org.scala-sbt#scripted-plugin"]
    check-missing: false
  }

  // frozen at v1.6.0 tag because dependencies have historically been fragile.
  // (perhaps this is overly cautious now, in 2019? not sure)
  // and forked (February 2019) from that tag to make some tiny ScalaCheck 1.13 vs 1.14 tweaks so tests pass
  ${vars.base} {
    name: "cats"
    uri:  ${vars.uris.cats-uri}
    // for some reason, adding the umbrella "catsJVM" project but excluding "bench"
    // (and "docs") doesn't succeed in removing the depending on cats-bench.
    // using deps.ignore doesn't fix it either. not sure how else to fix it
    // other than just enumerating what we want:
    extra.projects: ["coreJVM", "freeJVM", "kernelJVM", "kernelLawsJVM", "lawsJVM", "macrosJVM", "testkitJVM", "testsJVM", "alleycatsCoreJVM", "alleycatsTestsJVM"]
    extra.exclude: ["bench", "docs"]
    // tests are memory-hungry. hard to tell if occasional OutOfMemoryErrors are because
    // some random test input in a generative test hit a real bug, or whether memory needs
    // just fluctuate :-/  I've been gradually increasing this trying to fix an OOM in
    // ApplicativeSuite.  the repo's own .jvmopts has 6g
    extra.options: ["-Xmx6g"]
    // kind-projector org change
    check-missing: false
    deps.ignore: ["org.spire-math#kind-projector"]
    deps.inject: ${vars.base.deps.inject} ["org.typelevel#kind-projector"]
  }

]}
